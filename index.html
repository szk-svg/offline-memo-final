<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <meta name="theme-color" content="#ffffff"/>
  <link rel="manifest" href="./manifest.json">
  <title>offline-memo-final v7</title>
  <style>
    :root{
      --bg:#fff;
      --fg:#111;
      --muted:#666;
      --line:#e5e5e5;
      --accent:#111;
      --danger:#d11;
      --ok:#0a7;
      --shadow: 0 6px 24px rgba(0,0,0,.12);
      --radius: 12px;
      --radius2: 16px;
      --toolbarH: 56px;
      --safeB: env(safe-area-inset-bottom, 0px);
      --safeT: env(safe-area-inset-top, 0px);
    }
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      background:var(--bg);
      color:var(--fg);
      -webkit-text-size-adjust: 100%;
    }
    button{
      font: inherit;
      border: 1px solid var(--line);
      background:#fff;
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      touch-action: manipulation;
    }
    button:active{transform:translateY(1px)}
    button.primary{
      background:var(--accent);
      color:#fff;
      border-color:var(--accent);
    }
    button.danger{
      background:var(--danger);
      color:#fff;
      border-color:var(--danger);
    }
    button.ghost{
      background:transparent;
      border-color:transparent;
    }
    button.icon{
      padding:10px 10px;
      width:44px;
      height:44px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    input[type="text"], textarea{
      font: inherit;
      border:1px solid var(--line);
      border-radius:10px;
      padding:10px 12px;
      width:100%;
    }
    .app{
      height:100%;
      display:flex;
      flex-direction:column;
    }

    /* header */
    .topbar{
      position:sticky;
      top:0;
      z-index:5;
      background:rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
      padding: 10px 12px calc(10px + var(--safeT));
      display:flex;
      align-items:center;
      gap:10px;
    }
    .topbar .title{
      font-weight:700;
      font-size:16px;
      flex:1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .topbar .right{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .badge{
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      color:var(--muted);
      white-space:nowrap;
    }

    /* list */
    .listWrap{
      flex:1;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding: 12px;
    }
    .searchRow{
      display:flex;
      gap:8px;
      margin-bottom:12px;
      align-items:center;
    }
    .searchRow input{
      flex:1;
    }

    .sectionTitle{
      margin:14px 0 8px;
      font-weight:800;
      color:#222;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .sectionTitle small{
      font-weight:600;
      color:var(--muted);
    }

    .memoCard{
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:12px;
      margin-bottom:10px;
      box-shadow: 0 1px 0 rgba(0,0,0,.03);
      background:#fff;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .memoCard .left{
      flex:1;
      min-width:0;
    }
    .memoCard .t{
      font-weight:800;
      margin:0;
      font-size:15px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .memoCard .meta{
      margin-top:4px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .memoCard .snippet{
      margin-top:8px;
      font-size:13px;
      color:#222;
      line-height:1.35;
      display:-webkit-box;
      -webkit-line-clamp:2;
      -webkit-box-orient:vertical;
      overflow:hidden;
      word-break:break-word;
    }
    .memoCard .actions{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-end;
    }
    .dragHandle{
      user-select:none;
      font-weight:900;
      width:44px;
      height:44px;
      border:1px solid var(--line);
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#333;
      background:#fff;
      touch-action:none;
    }
    .pinBtn{
      width:44px;
      height:44px;
      border:1px solid var(--line);
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#fff;
    }
    .pinBtn.pinned{
      border-color:#111;
      background:#111;
      color:#fff;
    }

    .empty{
      padding:40px 16px;
      text-align:center;
      color:var(--muted);
    }

    /* editor */
    .editorWrap{
      position:fixed;
      inset:0;
      background:var(--bg);
      display:none;
      flex-direction:column;
      z-index:10;
    }
    .editorWrap.show{display:flex;}
    .editTop{
      position:sticky;
      top:0;
      z-index:11;
      background:rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
      padding: 10px 12px calc(10px + var(--safeT));
      display:flex;
      gap:8px;
      align-items:center;
    }
    .editTop .left{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .editTop .center{
      flex:1;
      min-width:0;
      display:flex;
      align-items:center;
    }
    .editTop .center input{
      font-weight:800;
    }
    .editTop .right{
      display:flex;
      gap:8px;
      align-items:center;
    }

    .editorBody{
      flex:1;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding: 12px 12px calc(var(--toolbarH) + 12px + var(--safeB));
    }

    .ce{
      border:1px solid var(--line);
      border-radius: var(--radius2);
      padding:12px;
      min-height: 55vh;
      line-height:1.45;
      outline:none;
      word-break:break-word;
      white-space:pre-wrap;
      background:#fff;
    }
    .ce:focus{
      border-color:#cfcfcf;
      box-shadow: 0 0 0 4px rgba(0,0,0,.06);
    }

    /* line nodes inside contenteditable */
    .line{
      display:block;
      padding: 2px 0;
    }
    .plainline{
      display:block;
    }
    .cbline{
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .cbbox{
      width: 22px;
      height: 22px;
      border: 2px solid #333;
      border-radius: 6px;
      margin-top: 2px;
      flex: 0 0 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:16px;
      line-height:1;
      user-select:none;
      cursor:pointer;
    }
    .cbline.checked .cbbox{
      background:#111;
      border-color:#111;
      color:#fff;
    }
    .cbtext{
      flex:1;
      min-width:0;
      outline:none;
      white-space:pre-wrap;
      word-break:break-word;
    }

    /* bottom toolbar (A案) */
    .bottomBar{
      position:fixed;
      left:0; right:0; bottom:0;
      height: calc(var(--toolbarH) + var(--safeB));
      padding: 10px 12px calc(10px + var(--safeB));
      background: rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      border-top:1px solid var(--line);
      display:flex;
      gap:10px;
      align-items:center;
      z-index:12;
    }
    .bottomBar .grow{flex:1}
    .bottomBar .group{
      display:flex;
      gap:8px;
      align-items:center;
    }

    /* modal */
    .modalOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.35);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 14px;
      z-index:50;
    }
    .modalOverlay.show{display:flex;}
    .modal{
      width:min(540px, 100%);
      background:#fff;
      border-radius:16px;
      box-shadow: var(--shadow);
      border:1px solid var(--line);
      padding: 14px;
    }
    .modal h3{
      margin:0 0 6px;
      font-size:16px;
    }
    .modal p{
      margin:0 0 12px;
      color:var(--muted);
      font-size:13px;
      line-height:1.45;
    }
    .modal .row{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }

    /* toast */
    .toast{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom: calc(16px + var(--toolbarH) + var(--safeB));
      background:#111;
      color:#fff;
      padding:10px 12px;
      border-radius:999px;
      font-size:13px;
      opacity:0;
      pointer-events:none;
      transition:.18s;
      z-index:60;
      max-width:min(92vw, 560px);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.show{opacity:1;}

    .hide{display:none!important}

    /* selection mode indicator */
    .selMode{
      border:1px solid #111;
      color:#111;
      background:#fff;
    }

    /* small */
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 12px;
      padding: 2px 6px;
      border:1px solid var(--line);
      border-radius: 8px;
      color:#222;
      background:#fafafa;
    }
  </style>
</head>
<body>
<div class="app" id="app">
  <div class="topbar">
    <div class="title" id="topTitle">メモ</div>
    <div class="right">
      <span class="badge" id="selBadge" style="display:none;">選択: <b id="selCount">0</b></span>
      <button class="icon" id="btnNew" title="新規">＋</button>
      <button class="icon" id="btnExport" title="書き出し">⇪</button>
      <button class="icon" id="btnImport" title="読み込み">⇩</button>
    </div>
  </div>

  <div class="listWrap" id="listWrap">
    <div class="searchRow">
      <input type="text" id="search" placeholder="検索（タイトル/本文）">
      <button id="btnSelToggle" class="icon" title="複数選択">✓</button>
    </div>

    <div class="sectionTitle">★固定 <small id="pinCount"></small></div>
    <div id="pinList"></div>

    <div class="sectionTitle">更新順 <small id="norCount"></small></div>
    <div id="norList"></div>

    <div class="empty hide" id="empty">メモがありません</div>
  </div>

  <!-- editor -->
  <div class="editorWrap" id="editorWrap">
    <div class="editTop">
      <div class="left">
        <button class="icon" id="btnBack" title="戻る">←</button>
      </div>
      <div class="center">
        <input type="text" id="titleInput" placeholder="タイトル">
      </div>
      <div class="right">
        <button class="icon" id="btnUndo" title="Undo">↶</button>
        <button class="icon" id="btnRedo" title="Redo">↷</button>
        <button class="primary" id="btnSave">保存</button>
        <button class="danger" id="btnDelete">削除</button>
      </div>
    </div>

    <div class="editorBody">
      <div class="ce" id="editor" contenteditable="true" spellcheck="false"></div>
    </div>

    <div class="bottomBar" id="bottomBar">
      <div class="group">
        <button class="icon" id="btnBold" title="太字"><b>B</b></button>
        <button class="icon" id="btnRed" title="赤字" style="color:#d11;">A</button>
        <button class="icon" id="btnCb" title="チェック化">☑</button>
      </div>
      <div class="grow"></div>
      <div class="group">
        <span class="kbd" id="dirtyHint" style="display:none;">未保存</span>
      </div>
    </div>
  </div>

  <!-- modals -->
  <div class="modalOverlay" id="modalOverlay">
    <div class="modal">
      <h3 id="modalTitle">確認</h3>
      <p id="modalText"></p>
      <div class="row" id="modalBtns"></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <input type="file" id="filePicker" class="hide" multiple>
</div>

<script>
/* =========================
   offline-memo-final v7
   STORAGE_KEY: offline_memo_final_v7
   ========================= */
const STORAGE_KEY = "offline_memo_final_v7";

/* ===== helpers ===== */
const $ = (id)=>document.getElementById(id);
const app = $("app");
const listWrap = $("listWrap");
const pinList = $("pinList");
const norList = $("norList");
const emptyEl = $("empty");
const searchEl = $("search");
const btnNew = $("btnNew");
const btnExport = $("btnExport");
const btnImport = $("btnImport");
const btnSelToggle = $("btnSelToggle");
const selBadge = $("selBadge");
const selCount = $("selCount");
const pinCount = $("pinCount");
const norCount = $("norCount");
const topTitle = $("topTitle");

const editorWrap = $("editorWrap");
const btnBack = $("btnBack");
const titleInput = $("titleInput");
const editor = $("editor");
const btnUndo = $("btnUndo");
const btnRedo = $("btnRedo");
const btnSave = $("btnSave");
const btnDelete = $("btnDelete");
const btnBold = $("btnBold");
const btnRed = $("btnRed");
const btnCb = $("btnCb");
const dirtyHint = $("dirtyHint");

const modalOverlay = $("modalOverlay");
const modalTitle = $("modalTitle");
const modalText = $("modalText");
const modalBtns = $("modalBtns");
const toastEl = $("toast");
const filePicker = $("filePicker");

function nowTs(){ return Date.now(); }
function fmtTs(ts){
  const d = new Date(ts);
  const pad = (n)=>String(n).padStart(2,"0");
  return `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
}
function escapeHtml(s){
  return (s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");
}
function toast(msg, ms=1400){
  toastEl.textContent = msg;
  toastEl.classList.add("show");
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(()=>toastEl.classList.remove("show"), ms);
}

function openModal({title="確認", text="", buttons=[]}){
  modalTitle.textContent = title;
  modalText.textContent = text;
  modalBtns.innerHTML = "";
  buttons.forEach(b=>{
    const bt = document.createElement("button");
    bt.textContent = b.text;
    bt.className = b.className || "";
    bt.addEventListener("click", ()=>{
      closeModal();
      b.onClick && b.onClick();
    });
    modalBtns.appendChild(bt);
  });
  modalOverlay.classList.add("show");
}
function closeModal(){
  modalOverlay.classList.remove("show");
}

function downloadBlob(filename, blob){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 8000);
}

function normalizeTitle(t){
  t = (t||"").trim();
  return t ? t : "無題";
}
function makeSafeFilename(name){
  return (name||"無題")
    .replace(/[\\\/:*?"<>|]/g, "_")
    .replace(/\s+/g," ")
    .trim() || "無題";
}

/* ===== state ===== */
let state = {
  memos: [],          // {id,title,html,updatedAt,createdAt,pinned}
  pinnedIds: [],      // pinned order
  normalOrderIds: [], // manual order for non-pinned
};
let view = {
  query: "",
  selecting: false,
  selected: new Set(), // ids
  editingId: null,
  dirty: false,
  lastSavedSnapshot: null,
  undoStack: [],
  redoStack: [],
};

function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}
function loadState(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return;
  try{
    const obj = JSON.parse(raw);
    if (obj && typeof obj === "object"){
      state = {
        memos: Array.isArray(obj.memos) ? obj.memos : [],
        pinnedIds: Array.isArray(obj.pinnedIds) ? obj.pinnedIds : [],
        normalOrderIds: Array.isArray(obj.normalOrderIds) ? obj.normalOrderIds : [],
      };
    }
  }catch(e){}
}

function genId(){
  return "m" + Math.random().toString(36).slice(2,10) + Date.now().toString(36);
}

function getMemoById(id){ return state.memos.find(m=>m.id===id) || null; }
function isPinned(id){
  const m = getMemoById(id);
  return !!(m && m.pinned);
}
function setPinned(id, pinned){
  const m = getMemoById(id);
  if (!m) return;
  m.pinned = !!pinned;
  if (m.pinned){
    // remove from normal order
    state.normalOrderIds = state.normalOrderIds.filter(x=>x!==id);
    // add to pinned order top if not exists
    if (!state.pinnedIds.includes(id)) state.pinnedIds.unshift(id);
  }else{
    state.pinnedIds = state.pinnedIds.filter(x=>x!==id);
    // normal order: keep manual order, if not exists push to head
    if (!state.normalOrderIds.includes(id)) state.normalOrderIds.unshift(id);
  }
}

function getSortedPinned(){
  const pinned = state.memos.filter(m=>m.pinned);
  // order by pinnedIds, fallback by updatedAt desc
  const map = new Map(pinned.map(m=>[m.id,m]));
  const arr = [];
  state.pinnedIds.forEach(id=>{
    const m = map.get(id);
    if (m){ arr.push(m); map.delete(id); }
  });
  const rest = [...map.values()].sort((a,b)=>b.updatedAt-a.updatedAt);
  return arr.concat(rest);
}
function getSortedNormal(){
  const normal = state.memos.filter(m=>!m.pinned);
  const map = new Map(normal.map(m=>[m.id,m]));
  const arr = [];
  state.normalOrderIds.forEach(id=>{
    const m = map.get(id);
    if (m){ arr.push(m); map.delete(id); }
  });
  // the rest by updatedAt desc
  const rest = [...map.values()].sort((a,b)=>b.updatedAt-a.updatedAt);
  return arr.concat(rest);
}

function applySearch(list){
  const q = view.query.trim().toLowerCase();
  if (!q) return list;
  return list.filter(m=>{
    const t = (m.title||"").toLowerCase();
    const body = (m.html||"").toLowerCase();
    return t.includes(q) || body.includes(q);
  });
}

/* ===== render list ===== */
function renderList(){
  const pinned = applySearch(getSortedPinned());
  const normal = applySearch(getSortedNormal());

  pinList.innerHTML = "";
  norList.innerHTML = "";

  pinCount.textContent = pinned.length ? `(${pinned.length})` : "";
  norCount.textContent = normal.length ? `(${normal.length})` : "";

  const total = pinned.length + normal.length;
  emptyEl.classList.toggle("hide", total !== 0);

  pinned.forEach(m=>pinList.appendChild(renderMemoCard(m, true)));
  normal.forEach(m=>norList.appendChild(renderMemoCard(m, false)));

  updateSelUI();
}

function getSnippetFromHtml(html){
  const tmp = document.createElement("div");
  tmp.innerHTML = html || "";
  const txt = (tmp.textContent || "").trim().replace(/\s+/g," ");
  return txt;
}

function renderMemoCard(m, pinnedSection){
  const card = document.createElement("div");
  card.className = "memoCard";
  card.dataset.id = m.id;

  const left = document.createElement("div");
  left.className = "left";

  const t = document.createElement("p");
  t.className = "t";
  t.textContent = normalizeTitle(m.title);

  const meta = document.createElement("div");
  meta.className = "meta";
  meta.innerHTML = `<span>更新: ${fmtTs(m.updatedAt)}</span><span>作成: ${fmtTs(m.createdAt)}</span>`;

  const snip = document.createElement("div");
  snip.className = "snippet";
  snip.textContent = getSnippetFromHtml(m.html).slice(0, 160);

  left.appendChild(t);
  left.appendChild(meta);
  left.appendChild(snip);

  const actions = document.createElement("div");
  actions.className = "actions";

  const pin = document.createElement("button");
  pin.className = "pinBtn" + (m.pinned ? " pinned" : "");
  pin.textContent = m.pinned ? "★" : "☆";
  pin.title = "固定/解除";
  pin.addEventListener("click", (ev)=>{
    ev.stopPropagation();
    setPinned(m.id, !m.pinned);
    saveState();
    renderList();
  });

  const drag = document.createElement("div");
  drag.className = "dragHandle";
  drag.textContent = "≡";
  drag.title = "長押しドラッグ";
  // 検索中は無効
  drag.style.opacity = view.query.trim() ? "0.3" : "1.0";
  drag.style.pointerEvents = view.query.trim() ? "none" : "auto";

  // selection checkbox button for multi-select
  const selBtn = document.createElement("button");
  selBtn.className = "icon";
  selBtn.textContent = view.selected.has(m.id) ? "✓" : " ";
  selBtn.title = "選択";
  selBtn.addEventListener("click", (ev)=>{
    ev.stopPropagation();
    if (!view.selecting) startSelecting();
    toggleSelected(m.id);
  });

  actions.appendChild(selBtn);
  actions.appendChild(pin);
  actions.appendChild(drag);

  card.appendChild(left);
  card.appendChild(actions);

  card.addEventListener("click", ()=>{
    if (view.selecting){
      toggleSelected(m.id);
      return;
    }
    openEditor(m.id);
  });

  enableDragReorder(drag, card, pinnedSection);

  return card;
}

/* ===== multi select ===== */
function startSelecting(){
  view.selecting = true;
  view.selected = new Set();
  updateSelUI();
}
function stopSelecting(){
  view.selecting = false;
  view.selected = new Set();
  updateSelUI();
}
function toggleSelected(id){
  if (view.selected.has(id)){
    view.selected.delete(id);
  }else{
    view.selected.add(id);
  }
  if (view.selected.size === 0){
    stopSelecting();
  }else{
    updateSelUI();
  }
  renderList();
}
function updateSelUI(){
  const n = view.selected.size;
  selBadge.style.display = view.selecting ? "" : "none";
  selCount.textContent = String(n);
  btnSelToggle.classList.toggle("selMode", view.selecting);
}

/* ===== drag reorder ===== */
let dragState = null;

function enableDragReorder(handle, card, pinnedSection){
  let pressTimer = null;
  let startY = 0;

  const onPointerDown = (e)=>{
    if (view.query.trim()) return; // search中は無効
    if (view.selecting) return;    // selection中は無効（誤操作防止）
    e.preventDefault();
    startY = e.clientY;
    pressTimer = setTimeout(()=>{
      beginDrag(e, handle, card, pinnedSection);
    }, 240);
  };
  const onPointerMove = (e)=>{
    if (!pressTimer) return;
    const dy = Math.abs(e.clientY - startY);
    if (dy > 8){
      clearTimeout(pressTimer);
      pressTimer = null;
    }
  };
  const onPointerUp = ()=>{
    if (pressTimer){
      clearTimeout(pressTimer);
      pressTimer = null;
    }
  };

  handle.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("pointermove", onPointerMove);
  window.addEventListener("pointerup", onPointerUp);
}

function beginDrag(e, handle, card, pinnedSection){
  const listEl = pinnedSection ? pinList : norList;
  const ids = pinnedSection ? state.pinnedIds : state.normalOrderIds;

  // ensure ids contains all current items in view (only when not searching)
  const current = [...listEl.querySelectorAll(".memoCard")].map(x=>x.dataset.id);
  current.forEach(id=>{
    if (!ids.includes(id)) ids.push(id);
  });

  dragState = {
    pinnedSection,
    listEl,
    ids,
    draggingId: card.dataset.id,
    startY: e.clientY,
    placeholder: document.createElement("div"),
    cardRect: card.getBoundingClientRect(),
    ghost: card.cloneNode(true),
  };

  const ph = dragState.placeholder;
  ph.style.height = dragState.cardRect.height + "px";
  ph.style.marginBottom = "10px";
  ph.style.border = "1px dashed #bbb";
  ph.style.borderRadius = "16px";
  ph.style.background = "#fafafa";

  card.parentNode.insertBefore(ph, card.nextSibling);

  const g = dragState.ghost;
  g.style.position = "fixed";
  g.style.left = dragState.cardRect.left + "px";
  g.style.top = dragState.cardRect.top + "px";
  g.style.width = dragState.cardRect.width + "px";
  g.style.zIndex = "999";
  g.style.pointerEvents = "none";
  g.style.opacity = "0.92";
  g.style.boxShadow = "0 10px 30px rgba(0,0,0,.18)";
  g.style.border = "1px solid #ddd";
  document.body.appendChild(g);

  card.style.visibility = "hidden";

  window.addEventListener("pointermove", onDragMove, {passive:false});
  window.addEventListener("pointerup", onDragEnd, {passive:false});
}

function onDragMove(e){
  if (!dragState) return;
  e.preventDefault();

  const dy = e.clientY - dragState.startY;
  const g = dragState.ghost;
  g.style.transform = `translateY(${dy}px)`;

  const cards = [...dragState.listEl.querySelectorAll(".memoCard")].filter(c=>c.dataset.id !== dragState.draggingId);
  const y = e.clientY;

  let insertBefore = null;
  for (const c of cards){
    const r = c.getBoundingClientRect();
    if (y < r.top + r.height/2){
      insertBefore = c;
      break;
    }
  }
  if (insertBefore){
    dragState.listEl.insertBefore(dragState.placeholder, insertBefore);
  }else{
    dragState.listEl.appendChild(dragState.placeholder);
  }
}

function onDragEnd(e){
  if (!dragState) return;
  e.preventDefault();

  window.removeEventListener("pointermove", onDragMove);
  window.removeEventListener("pointerup", onDragEnd);

  const listEl = dragState.listEl;
  const cardsInOrder = [...listEl.querySelectorAll(".memoCard, div")];
  // placeholder位置を使い、並びを確定
  const orderedIds = [];
  for (const node of listEl.children){
    if (node.classList && node.classList.contains("memoCard")){
      orderedIds.push(node.dataset.id);
    }else if (node === dragState.placeholder){
      orderedIds.push(dragState.draggingId);
    }
  }

  if (dragState.pinnedSection){
    state.pinnedIds = orderedIds;
  }else{
    state.normalOrderIds = orderedIds;
  }

  saveState();
  renderList();

  // cleanup
  dragState.ghost.remove();
  dragState.placeholder.remove();
  dragState = null;
}

/* ===== editor lines builder ===== */
function makePlainLine(text=""){
  const d = document.createElement("div");
  d.className = "line plainline";
  d.innerHTML = escapeHtml(text);
  return d;
}
function makeCbLine(text=""){
  const row = document.createElement("div");
  row.className = "line cbline";
  const box = document.createElement("span");
  box.className = "cbbox";
  box.textContent = "";
  const tx = document.createElement("div");
  tx.className = "cbtext";
  tx.contentEditable = "true";
  tx.spellcheck = false;
  tx.innerHTML = escapeHtml(text);
  row.appendChild(box);
  row.appendChild(tx);
  box.addEventListener("click", (ev)=>{
    ev.stopPropagation();
    row.classList.toggle("checked");
    updateDirtyFlag();
    schedulePushSnapshot();
  });
  return row;
}

function ensureLinesStructure(){
  // editor内を line ブロックに整形
  const children = [...editor.childNodes];
  if (children.length === 0){
    editor.appendChild(makePlainLine(""));
    return;
  }
  // if plain text nodes exist, wrap them
  children.forEach(ch=>{
    if (ch.nodeType === 3){
      const t = ch.textContent || "";
      const lines = t.split(/\r?\n/);
      const frag = document.createDocumentFragment();
      lines.forEach((ln,i)=>{
        frag.appendChild(makePlainLine(ln));
      });
      editor.replaceChild(frag, ch);
    }else if (ch.nodeType === 1){
      const el = ch;
      if (!el.classList.contains("line")){
        // convert div/p into line
        const txt = (el.textContent || "");
        const nl = makePlainLine(txt);
        editor.replaceChild(nl, el);
      }
    }
  });
}

function setCaretToStart(el){
  function setCaretToStart(el){
  const r = document.createRange();
  r.selectNodeContents(el);
  r.collapse(true);
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(r);
}
function setCaretToEnd(el){
  const r = document.createRange();
  r.selectNodeContents(el);
  r.collapse(false);
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(r);
}

function focusToPlainlineStart(pl){
  requestAnimationFrame(()=>{
    editor.focus();
    setCaretToStart(pl);
  });
}

/* ===== checkbox logic ===== */
function getCurrentLineEl(){
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return null;
  let node = sel.getRangeAt(0).startContainer;
  if (!node) return null;
  if (node.nodeType === 3) node = node.parentNode;
  if (!node) return null;
  const line = node.closest ? node.closest(".line") : null;
  return line;
}

function getSelectionText(){
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return "";
  return sel.toString();
}

function wrapSelectionToCbline(){
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return false;
  const text = sel.toString();
  if (!text) return false;

  // replace selection with cbline at cursor line
  const line = getCurrentLineEl();
  if (!line) return false;

  const cb = makeCbLine(text);
  line.replaceWith(cb);

  // add next plain line
  const pl = makePlainLine("");
  cb.after(pl);
  focusToPlainlineStart(pl);
  return true;
}

function toggleLineToCb(){
  const line = getCurrentLineEl();
  if (!line) return false;

  if (line.classList.contains("cbline")){
    // already cbline -> toggle checked
    line.classList.toggle("checked");
    updateDirtyFlag();
    schedulePushSnapshot();
    return true;
  }
  // convert to cbline
  const text = (line.textContent || "");
  const cb = makeCbLine(text);
  line.replaceWith(cb);
  const pl = makePlainLine("");
  cb.after(pl);
  focusToPlainlineStart(pl);
  return true;
}

/* ---- Enter 根治 + Backspace/Deleteでチェック解除（Gboard対策込み） ---- */
function isCaretAtStartOf(el){
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return false;
  const r = sel.getRangeAt(0);
  if (!r.collapsed) return false;
  // if startContainer is el itself
  if (r.startContainer === el && r.startOffset === 0) return true;

  // if inside text node
  const tmp = document.createRange();
  tmp.selectNodeContents(el);
  tmp.setEnd(r.startContainer, r.startOffset);
  const s = tmp.toString();
  return s.length === 0;
}

function handleEnterInsideCbline(){
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return false;
  const line = getCurrentLineEl();
  if (!line || !line.classList.contains("cbline")) return false;
  const tx = line.querySelector(".cbtext");
  if (!tx) return false;

  const atStart = isCaretAtStartOf(tx);
  if (atStart){
    // cbline先頭 Enter：空cbline作らない → 上にplainlineを作る
    const pl = makePlainLine("");
    line.before(pl);
    focusToPlainlineStart(pl);
    return true;
  }

  // split: extract text after caret from cbtext
  const r = sel.getRangeAt(0);
  const before = document.createRange();
  before.selectNodeContents(tx);
  before.setEnd(r.startContainer, r.startOffset);
  const after = document.createRange();
  after.selectNodeContents(tx);
  after.setStart(r.startContainer, r.startOffset);

  const afterText = after.toString();

  // delete after part from cbtext
  after.deleteContents();

  const pl = makePlainLine(afterText);
  line.after(pl);
  focusToPlainlineStart(pl);
  return true;
}

function handleBackspaceDeleteAroundCbline(key){
  const line = getCurrentLineEl();
  if (!line || !line.classList.contains("cbline")) return false;
  const tx = line.querySelector(".cbtext");
  if (!tx) return false;

  const atStart = isCaretAtStartOf(tx);
  if (!atStart) return false;

  // at start: Backspace/Delete should turn cbline back to plainline (unchecked)
  const text = tx.textContent || "";
  const pl = makePlainLine(text);
  line.replaceWith(pl);
  focusToPlainlineStart(pl);
  return true;
}

/* ★beforeinput：Android(Gboard)はここが本命 */
editor.addEventListener("beforeinput", (e)=>{
  const t = e.inputType || "";
  const data = (typeof e.data === "string") ? e.data : "";

  const looksLikeEnter =
    t === "insertParagraph" ||
    t === "insertLineBreak" ||
    (t === "insertText" && (data === "\n" || data === "\r" || data === "\r\n")) ||
    ((t === "insertCompositionText" || t === "insertFromComposition") &&
      (data.includes("\n") || data.includes("\r")));

  if (looksLikeEnter){
    const handled = handleEnterInsideCbline();
    if (handled){
      e.preventDefault();
      e.stopPropagation();
    }
    return;
  }

  if (t === "deleteContentBackward"){
    const handled = handleBackspaceDeleteAroundCbline("Backspace");
    if (handled){
      e.preventDefault();
      e.stopPropagation();
    }
    return;
  }

  if (t === "deleteContentForward"){
       const handled = handleBackspaceDeleteAroundCbline("Delete");
    if (handled){
      e.preventDefault();
      e.stopPropagation();
    }
    return;
  }
});

/* keydown：端末によっては来るので保険 */
editor.addEventListener("keydown", (e)=>{
  if (e.key === "Enter"){
    const handled = handleEnterInsideCbline();
    if (handled){
      e.preventDefault();
      e.stopPropagation();
      return;
    }
  }
  if (e.key === "Backspace" || e.key === "Delete"){
    const handled = handleBackspaceDeleteAroundCbline(e.key);
    if (handled){
      e.preventDefault();
      e.stopPropagation();
      return;
    }
  }
});

/* input：Androidが勝手に作る div/br を line 化 */
editor.addEventListener("input", ()=>{
  // convert stray <div><br></div> to plainline
  const els = [...editor.querySelectorAll("div")];
  els.forEach(el=>{
    if (el.classList.contains("line")) return;
    // plain div inside editor -> convert
    const txt = (el.textContent || "");
    const pl = makePlainLine(txt);
    el.replaceWith(pl);
  });

  const brOnly = [...editor.childNodes].filter(n=>n.nodeType===1 && n.tagName==="BR");
  brOnly.forEach(br=>{
    br.replaceWith(makePlainLine(""));
  });

  if (editor.childNodes.length === 0){
    editor.appendChild(makePlainLine(""));
  }

  updateDirtyFlag();
});

/* ===== formatting ===== */
function applyInline(tag, styleObj){
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return;
  const r = sel.getRangeAt(0);
  if (r.collapsed) return;

  const span = document.createElement(tag);
  if (styleObj){
    Object.keys(styleObj).forEach(k=>{
      span.style[k] = styleObj[k];
    });
  }
  try{
    r.surroundContents(span);
  }catch(e){
    // fallback: extract and wrap
    const frag = r.extractContents();
    span.appendChild(frag);
    r.insertNode(span);
  }
  sel.removeAllRanges();
  const nr = document.createRange();
  nr.selectNodeContents(span);
  nr.collapse(false);
  sel.addRange(nr);

  updateDirtyFlag();
  schedulePushSnapshot();
}

/* ===== editor open/save/undo ===== */
function openEditor(id){
  const m = getMemoById(id);
  if (!m) return;

  view.editingId = id;
  view.dirty = false;
  view.lastSavedSnapshot = null;
  view.undoStack = [];
  view.redoStack = [];

  titleInput.value = m.title || "";

  editor.innerHTML = "";
  // load html -> rebuild lines
  const tmp = document.createElement("div");
  tmp.innerHTML = m.html || "";
  // if stored as raw text (no .line)
  if (tmp.querySelector(".line")){
    editor.innerHTML = tmp.innerHTML;
  }else{
    const txt = (tmp.textContent || "");
    const lines = txt.split(/\r?\n/);
    lines.forEach(ln=>{
      editor.appendChild(makePlainLine(ln));
    });
    if (lines.length === 0) editor.appendChild(makePlainLine(""));
  }

  // rebind cbbox clicks (because innerHTML loaded)
  [...editor.querySelectorAll(".cbline")].forEach(row=>{
    const box = row.querySelector(".cbbox");
    if (box && !box._bound){
      box._bound = true;
      box.addEventListener("click", (ev)=>{
        ev.stopPropagation();
        row.classList.toggle("checked");
        updateDirtyFlag();
        schedulePushSnapshot();
      });
    }
  });

  ensureLinesStructure();

  editorWrap.classList.add("show");
  dirtyHint.style.display = "none";

  // focus rule: existing memo -> body focus
  requestAnimationFrame(()=>{
    editor.focus();
    // caret at end of last line
    const last = editor.querySelector(".line:last-child");
    if (last){
      if (last.classList.contains("cbline")){
        const tx = last.querySelector(".cbtext");
        if (tx) setCaretToEnd(tx);
      }else{
        setCaretToEnd(last);
      }
    }
  });

  pushSnapshot("open");
  updateTitleBar();
}

function openNewMemo(){
  const id = genId();
  const m = {
    id,
    title: "",
    html: "",
    createdAt: nowTs(),
    updatedAt: nowTs(),
    pinned:false,
  };
  state.memos.unshift(m);
  // normal order: new memo at head
  state.normalOrderIds = [id, ...state.normalOrderIds.filter(x=>x!==id)];
  saveState();
  renderList();

  view.editingId = id;
  view.dirty = false;
  view.lastSavedSnapshot = null;
  view.undoStack = [];
  view.redoStack = [];

  titleInput.value = "";

  editor.innerHTML = "";
  editor.appendChild(makePlainLine(""));

  editorWrap.classList.add("show");
  dirtyHint.style.display = "none";

  // focus rule: new memo -> title focus
  requestAnimationFrame(()=>{
    titleInput.focus();
    titleInput.select();
  });

  pushSnapshot("openNew");
  updateTitleBar();
}

function closeEditor(){
  editorWrap.classList.remove("show");
  view.editingId = null;
  view.dirty = false;
  view.lastSavedSnapshot = null;
  view.undoStack = [];
  view.redoStack = [];
  updateTitleBar();
}

function serializeEditorHtml(){
  // store as html of lines (preserve check state)
  return editor.innerHTML;
}
function updateDirtyFlag(){
  if (!view.editingId) return;
  const snap = getCurrentSnapshot();
  const changed = (view.lastSavedSnapshot !== snap);
  view.dirty = changed;
  dirtyHint.style.display = view.dirty ? "" : "none";
}

function getCurrentSnapshot(){
  const title = titleInput.value || "";
  const html = serializeEditorHtml();
  return JSON.stringify({title, html});
}

let pushTimer = null;
function schedulePushSnapshot(){
  clearTimeout(pushTimer);
  pushTimer = setTimeout(()=>{
    pushSnapshot("edit");
  }, 220);
}

function pushSnapshot(reason){
  if (!view.editingId) return;
  const snap = getCurrentSnapshot();
  const last = view.undoStack[view.undoStack.length-1];
  if (last && last.snap === snap) return;
  view.undoStack.push({snap, reason, at: nowTs()});
  if (view.undoStack.length > 120) view.undoStack.shift();
  view.redoStack = [];
}

function restoreSnapshot(snapStr){
  try{
    const obj = JSON.parse(snapStr);
    titleInput.value = obj.title || "";
    editor.innerHTML = obj.html || "";
    // rebind cbbox click
    [...editor.querySelectorAll(".cbline")].forEach(row=>{
      const box = row.querySelector(".cbbox");
      if (box && !box._bound){
        box._bound = true;
        box.addEventListener("click", (ev)=>{
          ev.stopPropagation();
          row.classList.toggle("checked");
          updateDirtyFlag();
          schedulePushSnapshot();
        });
      }
    });
    ensureLinesStructure();
    updateDirtyFlag();
  }catch(e){}
}

function doUndo(){
  if (view.undoStack.length <= 1) return;
  const cur = view.undoStack.pop();
  view.redoStack.push(cur);
  const prev = view.undoStack[view.undoStack.length-1];
  restoreSnapshot(prev.snap);
}
function doRedo(){
  if (view.redoStack.length === 0) return;
  const item = view.redoStack.pop();
  view.undoStack.push(item);
  restoreSnapshot(item.snap);
}

function saveCurrentMemo(){
  const id = view.editingId;
  if (!id) return;
  const m = getMemoById(id);
  if (!m) return;
  m.title = titleInput.value || "";
  m.html = serializeEditorHtml();
  m.updatedAt = nowTs();

  // 保存時の並び：通常メモは更新順セクション先頭へ（normalOrderIds先頭）
  if (!m.pinned){
    state.normalOrderIds = [id, ...state.normalOrderIds.filter(x=>x!==id)];
  }

  saveState();
  view.lastSavedSnapshot = getCurrentSnapshot();
  updateDirtyFlag();
  toast("保存しました");
  renderList();
  updateTitleBar();
}

function deleteCurrentMemo(){
  const id = view.editingId;
  if (!id) return;
  const m = getMemoById(id);
  if (!m) return;

  openModal({
    title:"削除",
    text:`「${normalizeTitle(m.title)}」を削除します。よろしいですか？`,
    buttons:[
      {text:"キャンセル", className:"", onClick:()=>{}},
      {text:"削除", className:"danger", onClick:()=>{
        state.memos = state.memos.filter(x=>x.id!==id);
        state.pinnedIds = state.pinnedIds.filter(x=>x!==id);
        state.normalOrderIds = state.normalOrderIds.filter(x=>x!==id);
        saveState();
        closeEditor();
        renderList();
        toast("削除しました");
      }}
    ]
  });
}

function confirmCloseEditor(){
  if (!view.dirty){
    closeEditor();
    return;
  }
  openModal({
    title:"未保存",
    text:"保存されていません。破棄して戻りますか？",
    buttons:[
      {text:"キャンセル", onClick:()=>{}},
      {text:"破棄して戻る", className:"danger", onClick:()=>closeEditor()},
    ]
  });
}

function updateTitleBar(){
  if (editorWrap.classList.contains("show")){
    topTitle.textContent = "編集";
  }else{
    topTitle.textContent = "メモ";
  }
}

/* ===== export / import ===== */
async function exportSelected(){
  const ids = [...view.selected];
  if (ids.length === 0){ toast("選択がありません"); return; }

  const memos = ids.map(id=>getMemoById(id)).filter(Boolean);
  if (memos.length === 0){ toast("選択がありません"); return; }

  if (memos.length === 1){
    const m = memos[0];
    const name = makeSafeFilename(normalizeTitle(m.title));
    const txt = htmlToText(m.html);
    downloadBlob(`${name}.txt`, new Blob([txt], {type:"text/plain"}));
    toast("txtを書き出しました");
    return;
  }

  // zip (store method)
  const entries = memos.map((m, idx)=>{
    const base = makeSafeFilename(normalizeTitle(m.title));
    return { name: `${dedupeName(base, idx, memos)}.txt`, text: htmlToText(m.html) };
  });

  const zipBlob = makeSimpleZip(entries);
  downloadBlob(`memos_${Date.now()}.zip`, zipBlob);
  toast("zipを書き出しました");
}

function dedupeName(base, idx, memos){
  // 同名があれば無題1/無題2 的に
  const seen = new Map();
  memos.forEach(mm=>{
    const b = makeSafeFilename(normalizeTitle(mm.title));
    seen.set(b, (seen.get(b)||0)+1);
  });
  if ((seen.get(base)||0) <= 1) return base;
  // count occurrences in order
  let n = 0;
  for (let i=0;i<=idx;i++){
    const b = makeSafeFilename(normalizeTitle(memos[i].title));
    if (b===base) n++;
  }
  return `${base}${n}`;
}

function htmlToText(html){
  const tmp = document.createElement("div");
  tmp.innerHTML = html || "";
  // convert cbline to checkbox symbol
  [...tmp.querySelectorAll(".cbline")].forEach(row=>{
    const checked = row.classList.contains("checked");
    const tx = row.querySelector(".cbtext");
    const t = (tx ? tx.textContent : row.textContent) || "";
    row.replaceWith(document.createTextNode((checked?"☑ ":"☐ ") + t));
  });
  // plain lines -> join by newline
  const lines = [...tmp.querySelectorAll(".line")].map(el=>{
    return (el.textContent || "").replace(/\u00a0/g," ");
  });
  if (lines.length) return lines.join("\n");
  return (tmp.textContent || "");
}

/* simple ZIP (store) */
function crc32(buf){
  let c = ~0;
  for (let i=0;i<buf.length;i++){
    c ^= buf[i];
    for (let k=0;k<8;k++){
      c = (c>>>1) ^ (0xEDB88320 & -(c & 1));
    }
  }
  return ~c >>> 0;
}
function u16(n){ return [n&255,(n>>>8)&255]; }
function u32(n){ return [n&255,(n>>>8)&255,(n>>>16)&255,(n>>>24)&255]; }

function makeSimpleZip(entries){
  // entries: [{name, text}]
  const encoder = new TextEncoder();
  const files = entries.map(ent=>{
    const nameBytes = encoder.encode(ent.name);
    const dataBytes = encoder.encode(ent.text);
    const crc = crc32(dataBytes);
    return {nameBytes, dataBytes, crc};
  });

  let offset = 0;
  const chunks = [];
  const central = [];

  files.forEach(f=>{
    const localHeader = [
      ...u32(0x04034b50),
      ...u16(20), ...u16(0), ...u16(0),
      ...u16(0), ...u16(0),
      ...u32(f.crc),
      ...u32(f.dataBytes.length),
      ...u32(f.dataBytes.length),
      ...u16(f.nameBytes.length),
      ...u16(0),
    ];
    chunks.push(new Uint8Array(localHeader));
    chunks.push(f.nameBytes);
    chunks.push(f.dataBytes);

    const centralHeader = [
      ...u32(0x02014b50),
      ...u16(20), ...u16(20),
      ...u16(0), ...u16(0),
      ...u16(0), ...u16(0),
      ...u32(f.crc),
      ...u32(f.dataBytes.length),
      ...u32(f.dataBytes.length),
      ...u16(f.nameBytes.length),
      ...u16(0), ...u16(0),
      ...u16(0), ...u16(0),
      ...u32(0),
      ...u32(offset),
    ];
    central.push(new Uint8Array(centralHeader));
    central.push(f.nameBytes);

    offset += localHeader.length + f.nameBytes.length + f.dataBytes.length;
  });

  const centralSize = central.reduce((a,c)=>a + c.length, 0);
  const centralOffset = offset;

  const end = [
    ...u32(0x06054b50),
    ...u16(0), ...u16(0),
    ...u16(files.length),
    ...u16(files.length),
    ...u32(centralSize),
    ...u32(centralOffset),
    ...u16(0),
  ];

  const blobParts = [...chunks, ...central, new Uint8Array(end)];
  return new Blob(blobParts, {type:"application/zip"});
}

async function importFiles(files){
  if (!files || files.length === 0) return;

  const list = [...files];
  // JSON優先：置換インポート
  const jsonFile = list.find(f=>f.name.toLowerCase().endsWith(".json"));
  if (jsonFile){
    const text = await jsonFile.text();
    try{
      const obj = JSON.parse(text);
      if (obj && typeof obj === "object"){
        // minimal validation
        if (Array.isArray(obj.memos)){
          state = {
            memos: obj.memos,
            pinnedIds: Array.isArray(obj.pinnedIds) ? obj.pinnedIds : [],
            normalOrderIds: Array.isArray(obj.normalOrderIds) ? obj.normalOrderIds : [],
          };
          saveState();
          renderList();
          toast("JSONをインポートしました（置換）");
          return;
        }
      }
      toast("JSON形式が不正です");
    }catch(e){
      toast("JSONの読み込みに失敗");
    }
    return;
  }

  // TXT複数：1ファイル=1メモとして追加
  const txtFiles = list.filter(f=>f.name.toLowerCase().endsWith(".txt"));
  if (txtFiles.length){
    for (const f of txtFiles){
      const text = await f.text();
      const id = genId();
      const title = f.name.replace(/\.txt$/i,"");
      const html = textToHtml(text);
      const memo = {id, title, html, createdAt: nowTs(), updatedAt: nowTs(), pinned:false};
      state.memos.unshift(memo);
      state.normalOrderIds = [id, ...state.normalOrderIds.filter(x=>x!==id)];
    }
    saveState();
    renderList();
    toast("TXTを追加しました");
    return;
  }

  toast("対応形式: .json / .txt");
}

function textToHtml(text){
  const lines = (text||"").replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
  const tmp = document.createElement("div");
  lines.forEach(ln=>{
    if (ln.startsWith("☑ ") || ln.startsWith("☐ ")){
      const checked = ln.startsWith("☑ ");
      const body = ln.slice(2);
      const row = makeCbLine(body);
      if (checked) row.classList.add("checked");
      tmp.appendChild(row);
    }else{
      tmp.appendChild(makePlainLine(ln));
    }
  });
  return tmp.innerHTML;
}

/* ===== export full json ===== */
function exportAllJson(){
  const json = JSON.stringify(state, null, 2);
  downloadBlob(`offline-memo-final_${Date.now()}.json`, new Blob([json], {type:"application/json"}));
  toast("JSONを書き出しました");
}

/* ===== UI events ===== */
searchEl.addEventListener("input", ()=>{
  view.query = searchEl.value || "";
  renderList();
});

btnNew.addEventListener("click", ()=>{
  stopSelecting();
  openNewMemo();
});

btnSelToggle.addEventListener("click", ()=>{
  if (view.selecting) stopSelecting();
  else startSelecting();
  renderList();
});

btnExport.addEventListener("click", ()=>{
  if (view.selecting && view.selected.size){
    exportSelected();
    return;
  }
  openModal({
    title:"書き出し",
    text:"選択中なら選択メモを書き出します。選択がない場合は全体JSONを書き出します。",
    buttons:[
      {text:"キャンセル", onClick:()=>{}},
      {text:"全体JSON", className:"primary", onClick:()=>exportAllJson()},
      {text:"選択を書き出し", onClick:()=>{
        if (!view.selecting || view.selected.size===0){
          toast("選択がありません");
          return;
        }
        exportSelected();
      }},
    ]
  });
});

btnImport.addEventListener("click", ()=>{
  openModal({
    title:"読み込み",
    text:"JSONは置換、TXTは追加です。",
    buttons:[
      {text:"キャンセル", onClick:()=>{}},
      {text:"ファイル選択", className:"primary", onClick:()=>{
        filePicker.value = "";
        filePicker.click();
      }},
    ]
  });
});
filePicker.addEventListener("change", async ()=>{
  const files = filePicker.files;
  await importFiles(files);
});

btnBack.addEventListener("click", ()=> confirmCloseEditor());
btnUndo.addEventListener("click", ()=>{ doUndo(); });
btnRedo.addEventListener("click", ()=>{ doRedo(); });
btnSave.addEventListener("click", ()=>{ saveCurrentMemo(); });
btnDelete.addEventListener("click", ()=>{ deleteCurrentMemo(); });

btnBold.addEventListener("click", ()=>{
  editor.focus();
  applyInline("span", {fontWeight:"700"});
});
btnRed.addEventListener("click", ()=>{
  editor.focus();
  applyInline("span", {color:"#d11"});
});

/* checkbox button：選択 or 行 */
btnCb.addEventListener("click", ()=>{
  editor.focus();

  const selText = getSelectionText().trim();
  if (selText){
    const ok = wrapSelectionToCbline();
    if (!ok){
      toast("チェック化できませんでした");
      return;
    }
    updateDirtyFlag();
    schedulePushSnapshot();
    return;
  }

  const ok = toggleLineToCb();
  if (!ok){
    toast("文字を選択するか、行にカーソルを置いて押してね");
    return;
  }
  updateDirtyFlag();
  schedulePushSnapshot();
});

/* ===== back key (Android) ===== */
window.addEventListener("popstate", (e)=>{
  if (editorWrap.classList.contains("show")){
    history.pushState(null, "", location.href);
    confirmCloseEditor();
  }
});
function enableBackIntercept(){
  history.pushState(null, "", location.href);
}
enableBackIntercept();

/* ===== init ===== */
loadState();
renderList();

/* SW register */
if ("serviceWorker" in navigator) {
  window.addEventListener("load", async () => {
    try{
      const reg = await navigator.serviceWorker.register("./sw.js", { updateViaCache: "none" });

      if (reg.waiting && navigator.serviceWorker.controller){
        openUpdateModal(reg.waiting);
      }

      reg.addEventListener("updatefound", ()=>{
        const sw = reg.installing;
        if (!sw) return;
        sw.addEventListener("statechange", ()=>{
          if (sw.state === "installed" && navigator.serviceWorker.controller){
            toast("更新あり");
            openUpdateModal(sw);
          }
        });
      });

      navigator.serviceWorker.addEventListener("controllerchange", ()=> location.reload());
      setInterval(()=>{ reg.update().catch(()=>{}); }, 60 * 60 * 1000);
    }catch(e){}
  });
}

let pendingSw = null;
function openUpdateModal(sw){
  pendingSw = sw;
  openModal({
    title:"更新",
    text:"新しいバージョンがあります。再起動しますか？",
    buttons:[
      {text:"あとで", onClick:()=>{}},
      {text:"再起動", className:"primary", onClick:()=>{
        try{
          pendingSw && pendingSw.postMessage({type:"SKIP_WAITING"});
        }catch(e){}
      }},
    ]
  });
}
</script>
</body>
</html>